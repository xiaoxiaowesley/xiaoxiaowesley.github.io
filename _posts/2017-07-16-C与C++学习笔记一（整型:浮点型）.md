---
layout: post
tags: [c/c++]
---

```clike
工作中经常使用到C/C++，为对C有个比较深刻的了解，重新拾起学习C的任务。在看书的同时，记录下思考的过程，也记录下重要的知识点。

# 从数据的存储开始

计算机中的数据都存储在内存中，这就离不开各种数据类型在内存中的编码方式。从最简单的整型开始聊聊，整型数据在内存是如何编码以及必须要mark的坑。

# 整型中的有符号以及无符号

无符号即数据不能表示负数。
有符号即数据的最高位用来表示正负。

如十六位机器中：
unsigned int a = 1;
十六进制编码为：0x1
二进制编码为：0b00000000 00000001 

int a = -1;
十六进制编码为：0xffff
二进制编码为：0b11111111 11111111

# 如何表达负数（有符号数）编码

负数的编码可由正数的补码（反码加一）可以得到
如得到 -1 的编码。
-1的正数为 0x1，
0x1 的补码为 0xffff/0xb11111111 11111111 ，（反码  0xfffe/0b11111111 11111110 加上1  ）


# 使用整型的建议

## 注意有/无符号数据比较
上面提及到，有/无符号编码的格式比较重要的一个区别便是其最高位是否使用1来表示负数。
但在C语言中，两数进行比较时，并不会严格的检查数据的类型，而是直接对比二进制编码中数据的大小。在有符号中的负数经常会表示为一个非常大的数。
例如，下面代码中，结果会输出与异常的 “a smaller than b”
所以，千万要避免有/无符号数据大小的直接对比。

这是因为(32位cpu),
a  的二进制编码为 0b 00000000 00000000  00000000  00000001
b 的二进制编码位  0b 11111111 11111111 11111111 11111111
b的值在比较中远远大于a。

```
unsigned int a =100;
int b = -1;
if (a > b) {
	printf("a larger than b \n");
}else{
	printf("a smaller than b \n");
}
```

正确的做法是，在有/无符号整型数据比较时，强制转换成有符号数

```
  unsigned int a =100;
  int b = -1;
  if ((int)a > b) {
	  printf("a larger than b \n");
  }else{
	  printf("a smaller than b \n");
  }
```

## 整型数据边界问题

数据所能代表的范围有限的，当使用到数据时，需考虑到边界值。
有/无符号整型超过最大值时，会回到0，继续累加。
在使用时也需要注意。

例如下面例子：
a此时为unsigned char 的最大值65535，二进制编码为 0b11111111，
当加一时，发生回绕，二进制编码变为 0b00000000
此时输出s < 100，这种会让人十分疑惑的问题。
```
unsigned char s = 65535;
s = s+1;
if (s > 100) {
	printf("s > 100");
}else{
	printf("s < 100");
}
```

同样情况也会发生在有符号整型数据中

# 浮点数在计算机中的编码

浮点数其实就是科学计数法在计算机中的表现形式。
只是在日常的使用场景中使用的是十进制，需要转换成计算机认识的科学计数法的二进制表示形式。
科学计数法中由符号位,指数位 ,有效数字位三部分组成。三者就可以表达

| 符号位 | 指数位 | 有效数字位 |
| ------------- |:-------------:| -----:|
| S | E | M |

如十进制123.4  （0b1111001.01100）：
       十进制科学计数法  1.234 * 10^2
	   二进制科学计数法  1.11100101100 * 2^6

走到这便会发现一个问题，十进制数转换到二进制时，小数部分在使用二进制数表达时，很多情况下并不能精确表示。这也浅出一个编程中经常遇到的问题，**浮点数为什么很多情况下并不是精确的**

## 浮点数为什么是不精确的？

最直接的原因，便是十进制数的小数位，在小数最后一位非5时，并不能精确的转换成二进数。
如。
123.5 转换成二进制数

整数部分 

	123 = 2^6 + 2^5 + 2^4 +2^3 +2^0 = 0b11111001

小数部分 

		0.5 = 2^-1

**123.5 转换成二进制  0b 1111001.1**

但是对于小数最后一位非5的情况，如 123.4

整数部分

	 123 = 2^6 + 2^5 + 2^4 +2^3 +2^0 = 0b11111001

小数部分 0.4 使用转换公式进行计算
	
	0.4 * 2 = 0.8 取整数位 0 
	0.8 * 2 = 1.6  取整数位 1 
	0.6 * 2 = 1.2  取整数位 1
	0.2 * 2 = 0.4  取整数位 0
	0.4 * 2 = 0.8 取整数位 0 
	0.8 * 2 = 1.6  取整数位 1 
	....
最后发现，根据转换公式，123.4其实无法得到一个精确值，只能获得一个大约的值如0b11111001.011001 ，也就是说，在计算机保持的值中，永远也不是个精确的值

例如，下面a-b不会得到0.1，而是接近0.1的0.0999998
```
 float a = 123.5;
 float b = 123.4;
 printf("a-b = %f \n",a-b);  //a-b = 0.099998 
        
```

但对于最后一位小数位5的浮点数而言，二进制精度会得以保证
如下例中输出的结果为 a-b = 1.000000
```
	float a = 123.5;
    float b = 122.5;
    printf("a-b = %f \n",a-b); // a-b = 1.000000
```

在实际运用中，对于浮点数的比较是否相同，我们只能约定一个范围来进行判断

```
    float a = 123.4;
    if ( (a-123.4) >0 && (a-123.4) < 0.001) {
	    printf("a near 123.4");
	}
```
```
